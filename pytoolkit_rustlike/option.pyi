"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Callable, Generic, Iterator, TypeVar

"""
PyToolkit Option - Rust風のOption型実装

## 設計方針

このモジュールはRustのOption<T>型をPythonで再現したものです。
Resultクラスと同様に、実用性と型安全性のバランスを重視した設計を採用しています。

### 主要な設計判断

1. **UnwrapError の統一採用**
   - Nothing.unwrap()は一律でUnwrapErrorを発生
   - Resultクラスとの一貫性を保持

2. **完全抽象基底クラス設計**
   - Optionクラスは完全に抽象的
   - SomeとNothingで全メソッドを一貫して実装

3. **Rust準拠のメソッド群**
   - expect(), unwrap_or_else(), map_or(), map_or_else()等を実装
   - inspect(), filter(), flatten()等の実用的メソッドを追加

詳細な実装背景は CLAUDE.md を参照してください。
"""
T = TypeVar("T")
U = TypeVar("U")
class Option(ABC, Generic[T]):
    @abstractmethod
    def is_some(self) -> bool:
        ...
    
    @abstractmethod
    def is_nothing(self) -> bool:
        ...
    
    @abstractmethod
    def unwrap(self) -> T:
        ...
    
    @abstractmethod
    def expect(self, msg: str) -> T:
        ...
    
    @abstractmethod
    def unwrap_or(self, default: T) -> T:
        ...
    
    @abstractmethod
    def unwrap_or_else(self, f: Callable[[], T]) -> T:
        ...
    
    @abstractmethod
    def map(self, f: Callable[[T], U]) -> Option[U]:
        ...
    
    @abstractmethod
    def map_or(self, default: U, f: Callable[[T], U]) -> U:
        ...
    
    @abstractmethod
    def map_or_else(self, default_f: Callable[[], U], f: Callable[[T], U]) -> U:
        ...
    
    @abstractmethod
    def and_then(self, f: Callable[[T], Option[U]]) -> Option[U]:
        ...
    
    @abstractmethod
    def filter(self, predicate: Callable[[T], bool]) -> Option[T]:
        ...
    
    @abstractmethod
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]:
        ...
    
    @abstractmethod
    def and_(self, optb: Option[U]) -> Option[U]:
        ...
    
    @abstractmethod
    def or_(self, optb: Option[T]) -> Option[T]:
        ...
    
    @abstractmethod
    def inspect(self, f: Callable[[T], None]) -> Option[T]:
        ...
    
    @abstractmethod
    def __iter__(self) -> Iterator[T]:
        ...
    
    @abstractmethod
    def match(self, some: Callable[[T], U], nothing: Callable[[], U]) -> U:
        ...
    


@dataclass(frozen=True)
class Some(Option[T]):
    _value: T
    def is_some(self) -> bool:
        ...
    
    def is_nothing(self) -> bool:
        ...
    
    def unwrap(self) -> T:
        ...
    
    def expect(self, msg: str) -> T:
        ...
    
    def unwrap_or(self, default: T) -> T:
        ...
    
    def unwrap_or_else(self, f: Callable[[], T]) -> T:
        ...
    
    def map(self, f: Callable[[T], U]) -> Option[U]:
        ...
    
    def map_or(self, default: U, f: Callable[[T], U]) -> U:
        ...
    
    def map_or_else(self, default_f: Callable[[], U], f: Callable[[T], U]) -> U:
        ...
    
    def and_then(self, f: Callable[[T], Option[U]]) -> Option[U]:
        ...
    
    def filter(self, predicate: Callable[[T], bool]) -> Option[T]:
        ...
    
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]:
        ...
    
    def and_(self, optb: Option[U]) -> Option[U]:
        ...
    
    def or_(self, optb: Option[T]) -> Option[T]:
        ...
    
    def inspect(self, f: Callable[[T], None]) -> Option[T]:
        ...
    
    def __iter__(self) -> Iterator[T]:
        ...
    
    def match(self, some: Callable[[T], U], nothing: Callable[[], U]) -> U:
        ...
    


class Nothing(Option[T]):
    def is_some(self) -> bool:
        ...
    
    def is_nothing(self) -> bool:
        ...
    
    def unwrap(self) -> T:
        ...
    
    def expect(self, msg: str) -> T:
        ...
    
    def unwrap_or(self, default: T) -> T:
        ...
    
    def unwrap_or_else(self, f: Callable[[], T]) -> T:
        ...
    
    def map(self, f: Callable[[T], U]) -> Option[U]:
        ...
    
    def map_or(self, default: U, f: Callable[[T], U]) -> U:
        ...
    
    def map_or_else(self, default_f: Callable[[], U], f: Callable[[T], U]) -> U:
        ...
    
    def and_then(self, f: Callable[[T], Option[U]]) -> Option[U]:
        ...
    
    def filter(self, predicate: Callable[[T], bool]) -> Option[T]:
        ...
    
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]:
        ...
    
    def and_(self, optb: Option[U]) -> Option[U]:
        ...
    
    def or_(self, optb: Option[T]) -> Option[T]:
        ...
    
    def inspect(self, f: Callable[[T], None]) -> Option[T]:
        ...
    
    def __iter__(self) -> Iterator[T]:
        ...
    
    def match(self, some: Callable[[T], U], nothing: Callable[[], U]) -> U:
        ...
    


